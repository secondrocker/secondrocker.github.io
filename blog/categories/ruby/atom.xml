<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | elephant]]></title>
  <link href="http://me.angry-arthas.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://me.angry-arthas.com/"/>
  <updated>2015-06-08T01:46:32+08:00</updated>
  <id>http://me.angry-arthas.com/</id>
  <author>
    <name><![CDATA[secondrocker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Instance_eval,instance_exec,class_eval,class_exec 区别]]></title>
    <link href="http://me.angry-arthas.com/blog/2015/06/07/instance-ev-instance-exec-class-eval-class-exec-qu-bie/"/>
    <updated>2015-06-07T23:52:08+08:00</updated>
    <id>http://me.angry-arthas.com/blog/2015/06/07/instance-ev-instance-exec-class-eval-class-exec-qu-bie</id>
    <content type="html"><![CDATA[<p>对于instance_eval和class_eval，在看ruby元编程时以为搞清楚了，但最近发现一种情况，却又让我迷糊了：
class_eval
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">class_eval</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">a</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">a</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">define_method</span> <span class="ss">:b</span> <span class="k">do</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">b</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">a</span> <span class="c1"># &amp;lsquo;a&amp;rsquo;</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">b</span> <span class="c1"># &amp;lsquo;b&amp;rsquo;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">a</span><span class="err">和</span><span class="n">b</span><span class="err">都是</span><span class="n">A</span><span class="err">的实例方法</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;</span>
</span><span class='line'><span class="sr">instance_eval</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;class A</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">A.instance_eval do</span>
</span><span class='line'><span class="sr">  def a</span>
</span><span class='line'><span class="sr">    puts &amp;lsquo;a&amp;rsquo;</span>
</span><span class='line'><span class="sr">  end</span>
</span><span class='line'><span class="sr">  define_method :b do</span>
</span><span class='line'><span class="sr">    puts &amp;lsquo;b&amp;rsquo;</span>
</span><span class='line'><span class="sr">  end</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">A.new.b # &amp;lsquo;b&amp;rsquo; b为实例方法</span>
</span><span class='line'><span class="sr">A.new.a #  no method error!!!</span>
</span><span class='line'><span class="sr">A.a # ‘a’</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>为什么在instance_eval中 def 和define_method定义的一个为类方法(类的单件方法) 一个为实例方法呢？</p>

<p>要解释这个问题，首先要有以下概念:
ruby在执行时，会一直追踪当前对象（receiver）即self，但也会追踪当前类(current class)。instance_eval和class_eval都会修改self和current class:
* klass.class_eval 修改self为klass，修改current class为klass
* obj.instance_eval 修改self为obj,修改current class为
  obj的eigen_class（singleton_class)。</p>

<p>了解了以上知识，我们知道define_method的接受者为self,class_eval和instance_eval都改变self为调用者本身，所以定义的为实例方法；而对def起作用的是当前类（current class），class_eval修改当前类为调用者本身，所以定义的是类方法，而instance_eval修改当前类为调用者的eigen_class(singleton_class)，所以定义的是类方法(类的单件方法)。</p>

<p>另外，class_eval仅类可调用，instance_eval则类和对象都可调用。</p>

<p>class(instance)<em>exec与eval基本相似，但有以下不同：
* </em>evals既可传递字符串，也可传递块，如123.instance_eval &lsquo;to_s&rsquo;
* <em>exec只能传递块、不能传字符串，但</em>exec可以为block传递参数如  Class.instance_exec(&lsquo;Self&rsquo;){|x|p &ldquo;#{x}:self&rdquo;}</p>

<p>至此，class_eval，instance_eval,instance_exec,instance_eval概念基本都透彻了。
对于current class有些未说清的（未研究透彻,初步判断current class 对关键字起作用，self对方法调用起作用~），回头研究完单写一篇。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对hash进行递归操作]]></title>
    <link href="http://me.angry-arthas.com/blog/2015/05/11/dui-hashjin-xing-di-gui-cao-zuo/"/>
    <updated>2015-05-11T20:49:11+08:00</updated>
    <id>http://me.angry-arthas.com/blog/2015/05/11/dui-hashjin-xing-di-gui-cao-zuo</id>
    <content type="html"><![CDATA[<blockquote><p>将hash {a:1,b:{c1:2,c2:3,c3:{d1:4,d2:5},e:6}}转化为下面字符串
a = 1 , b_c1 = 2 , b_c2 = 3 , b_c3_d1 = 4 , b_c3_d2 = 5 , b_e = 6</p></blockquote>

<pre><code class="ruby">hash = {a:1,b:{c1:2,c2:3,c3:{d1:4,d2:5},e:6}}

def unfold(hash,p="")
  arr = []
  hash.each do|k,v|
    if v.instance_of? Hash 
      arr += unfold(v,p+k.to_s+"_")
    else
      arr &lt;&lt; "#{p}#{k.to_s} = #{v.to_s}"
    end
  end
  arr
end

puts unfold(hash).join " , "
</code></pre>

<blockquote><p>递归操作一般用于将问题复杂度降低，但感觉ruby的栈使递归无法发挥，稍微大点的递归就会导致栈溢出，之前写的递归版本的插入排序，同样的思路在java/java/c#都很好用，但在ruby中就是不行，要么调整栈的大小，但运行缓慢，很多时候总是得换为循环，感觉应该不是算法的问题,不知道什么时候ruby才能解决这个问题</p>

<hr />

<p>之前写的插入排序
<code>ruby
def insertSort(left=[],arr)
    return left unless (x=arr.pop)
    left.each_with_index do |l,i|
        if l&gt;x
            left.insert i,x
            return insertSort left,arr
        end
    end
    left.push x
    return insertSort left,arr
end
arr=[]
arrE=(1..10000).to_a
10000.times do |t|
    tmp=rand(arrE.count)
    arr.push (arrE.delete_at tmp)
end
puts (insertSort arr)
</code></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Super_method]]></title>
    <link href="http://me.angry-arthas.com/blog/2015/03/18/super-method/"/>
    <updated>2015-03-18T16:33:21+08:00</updated>
    <id>http://me.angry-arthas.com/blog/2015/03/18/super-method</id>
    <content type="html"><![CDATA[<pre><code class="ruby">class A
  def show
    "a method"
  end
end

class B&lt;A
  def show
    "b method"
  end
end
</code></pre>

<p>怎样用类B的对象调用A的show方法?
<code>ruby
B.new.method(:show).super_memthod.call  #ruby 2.2可用
</code>
2.2之前
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">show</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">a</span> <span class="nb">method</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;class B&amp;lt;A</span>
</span><span class='line'><span class="sr">  alias_method :super_show ,:show</span>
</span><span class='line'><span class="sr">  def show</span>
</span><span class='line'><span class="sr">    &amp;ldquo;b method&amp;rdquo;</span>
</span><span class='line'><span class="sr">  end</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">B.new.super_show</span>
</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby元编程1]]></title>
    <link href="http://me.angry-arthas.com/blog/2014/08/08/rubyyuan-bian-cheng-1/"/>
    <updated>2014-08-08T10:59:50+08:00</updated>
    <id>http://me.angry-arthas.com/blog/2014/08/08/rubyyuan-bian-cheng-1</id>
    <content type="html"><![CDATA[<h1>ruby元编程之eigenclass</h1>

<pre><code class="ruby">class BasicObject
  def self.eigenclass
    class &lt;&lt; self
      self
    end
  end
  def eigenclass
    class &lt;&lt; self
      self
    end
  end
end

class A
  def self.haha
    "ah"
  end
end

class B &lt; A
end

#对象eigenclass的superclass就是对象的类
b=B.new
p b.eigenclass.superclass == B
#类的eigenclass的superclass是类超类的eigenclass
p B.eigenclass.superclass == B.superclass.eigenclass
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSPEC学习1]]></title>
    <link href="http://me.angry-arthas.com/blog/2014/08/08/rspecxue-xi-1/"/>
    <updated>2014-08-08T09:48:01+08:00</updated>
    <id>http://me.angry-arthas.com/blog/2014/08/08/rspecxue-xi-1</id>
    <content type="html"><![CDATA[<p>rails 安装 rspec
- gem &lsquo;rspec-rails&rsquo;</p>

<p>创建rspec配置文件
- rails g rspec:install</p>

<p>should与should_not
- 对象如有valid?之类的方法，test可这么写model.should be_valid或model.should_not be_valid
- model.should == xx  <strong>等同</strong> model.should eq xx</p>

<p>expect
- expect(model).to eq  some_thing</p>

<p>let与before
- let与before(:each)的一个区别是before可以初始化变量,let不能before可以这样
<code>ruby
before(:each) do
    king="亚历山大"
end
</code>
- before(:each) 每个测试相互独立，分别调用这个
- before(:all)只调用这个一次
- let可用于定义变量，如下，在测试用例中可使用 king_of_zombie变量
<code>ruby
  let(:king_of_zombie) do
    "邓肯"
  end
</code>
Load RSpec 2.x support by adding the following line (typically to your spec_helper.rb file):
require &lsquo;capybara/rspec&rsquo;
If you are using Rails, put your Capybara specs in spec/features.
If you are not using Rails, tag all the example groups in which you want to use Capybara with :type => :feature.
You can now write your specs like so:
describe &ldquo;the signin process&rdquo;, :type => :feature do
  before :each do
    User.make(:email => &lsquo;<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#117;&#115;&#101;&#x72;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x75;&#x73;&#101;&#114;&#64;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#109;</a>&rsquo;, :password => &lsquo;caplin&rsquo;)
  end
<code>ruby
  it "signs me in" do
    visit '/sessions/new'
    within("#session") do
      fill_in 'Login', :with =&gt; 'user@example.com'
      fill_in 'Password', :with =&gt; 'password'
    end
    click_link 'Sign in'
    expect(page).to have_content 'Success'
  end
end
</code>
<a href="http://rubydoc.info/gems/rspec-rails/file/Capybara.md">http://rubydoc.info/gems/rspec-rails/file/Capybara.md</a>
<a href="https://github.com/rspec/rspec-rails">https://github.com/rspec/rspec-rails</a></p>

<p>Many users have been confused by the co-existence of the the Capybara::DSL (visit/page) alongside the rack-test DSL (get|post|put|delete|head/response.body) in examples in spec/requests and spec/controllers. As of rspec-rails-2.11.1 and capybara-2.0.0.beta2, these are separated as follows:</p>

<p>Capybara::DSL is included
- spec/features</p>

<p>rack-test DSL is included in
- spec/requests and spec/controllers</p>

<p>Capybara::RSpecMatchers is added to examples in:
- spec/features
- spec/controllers
- spec/views
- spec/helpers
- spec/mailers</p>

<p>2012年6月,Rspec开发团队宣布,在v2.11中使用了新句法
来替代传统的should式句法,如
<code>ruby
it "is true when true" do
 true.should be_true
end
</code>
新句法会把要测试的值传递给 expect() 方法,然后和匹配器比较:
<code>ruby
it "is true when true" do
 expect(true).to be_true
end
</code></p>

<p>当有多个it &ldquo;xxxx&rdquo; do end 而测试的主题一致时，
可用
<code>ruby
subject{@object}
it { should eq xx}
it { should have_content("cccc")}
</code></p>
]]></content>
  </entry>
  
</feed>
